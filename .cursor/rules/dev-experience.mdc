# Reglas de Experiencia de Desarrollo

Este archivo define las reglas y estándares para mejorar la experiencia de desarrollo, estructura de código y uso de herramientas.

## Idioma del Código

**IMPORTANTE**: El idioma principal del código, comentarios, nombres de variables, funciones, tipos, interfaces y toda la documentación técnica será **inglés**. Esto incluye:

- Nombres de variables, funciones, componentes y tipos
- Comentarios en el código
- Mensajes de error en el código (no en la UI)
- Nombres de archivos y carpetas
- Mensajes de commit (aunque pueden tener descripciones en otros idiomas)

Las traducciones para la interfaz de usuario (i18n) pueden incluir múltiples idiomas, pero el código fuente siempre estará en inglés.

## Principios Generales

1. **Consistencia**: Mantener patrones consistentes en todo el código
2. **Legibilidad**: El código debe ser fácil de leer y entender
3. **Mantenibilidad**: Estructura que facilite cambios futuros
4. **Type Safety**: Aprovechar TypeScript al máximo
5. **Developer Experience**: Herramientas y configuraciones que mejoren la productividad
6. **Idioma inglés**: Todo el código fuente debe estar en inglés

## Reglas Específicas

### Estructura de Carpetas

Seguir la estructura establecida del proyecto:

```
src/
├── features/          # Features organizadas por dominio
│   └── dashboard/
│       ├── components/
│       ├── hooks/
│       ├── services/
│       └── index.ts   # Barrel export
├── layout/            # Componentes de layout compartidos
│   ├── components/
│   └── types/
├── shared/            # Código compartido entre features
│   ├── components/    # Componentes reutilizables
│   ├── hooks/         # Hooks compartidos
│   └── utils/         # Utilidades
├── i18n/              # Configuración de internacionalización
└── assets/            # Recursos estáticos
```

**Principios:**
- Cada feature debe ser auto-contenida
- Usar barrel exports (`index.ts`) para exports públicos
- Separar concerns: componentes, lógica, servicios

**Ejemplo de estructura de feature:**

```
features/
└── users/
    ├── components/
    │   ├── UserList.tsx
    │   └── UserForm.tsx
    ├── hooks/
    │   ├── useUsers.ts
    │   └── useUserForm.ts
    ├── services/
    │   └── userService.ts
    ├── types/
    │   └── user.types.ts
    └── index.ts        # export * from './components'; export * from './hooks';
```

### TypeScript

#### Tipado Estricto

Siempre usar tipos explícitos, evitar `any`:

**Ejemplo correcto:**

```typescript
interface User {
  id: string;
  name: string;
  email: string;
  createdAt: Date;
}

function getUser(id: string): Promise<User> {
  return fetch(`/api/users/${id}`).then(res => res.json());
}
```

**Ejemplo incorrecto:**

```typescript
// ❌ Evitar any
function getUser(id: any): Promise<any> {
  return fetch(`/api/users/${id}`).then(res => res.json());
}
```

#### Tipos vs Interfaces

- Usar `interface` para objetos y contratos de componentes
- Usar `type` para uniones, intersecciones y tipos derivados

**Ejemplo:**

```typescript
// Interface para objetos
interface MenuItem {
  id: string;
  label: string;
  path?: string;
}

// Type para uniones
type Status = 'loading' | 'success' | 'error';

// Type para tipos derivados
type MenuItemWithIcon = MenuItem & {
  icon: React.ComponentType;
};
```

#### Tipos de Props de Componentes

Siempre tipar props de componentes:

**Ejemplo correcto:**

```typescript
interface ButtonProps {
  label: string;
  onClick: () => void;
  variant?: 'primary' | 'secondary';
  disabled?: boolean;
}

export function Button({ label, onClick, variant = 'primary', disabled }: ButtonProps) {
  // ...
}
```

#### Tipos de Hooks

Tipar valores de retorno de hooks:

**Ejemplo correcto:**

```typescript
interface UseDashboardDataReturn {
  data: DashboardData | null;
  loading: boolean;
  error: string | null;
  refetch: () => Promise<void>;
}

export function useDashboardData(): UseDashboardDataReturn {
  // ...
}
```

### Nomenclatura

#### Variables y Funciones

- **camelCase** para variables y funciones
- Nombres descriptivos y específicos
- Evitar abreviaciones innecesarias

**Ejemplo correcto:**

```typescript
const userDashboardData = fetchUserData();
const isLoading = true;
const hasError = false;

function calculateTotalPrice(items: CartItem[]): number {
  // ...
}
```

**Ejemplo incorrecto:**

```typescript
// ❌ Nombres poco descriptivos
const ud = fetchUD();
const ld = true;
const calc = (i) => { /* ... */ };
```

#### Componentes

- **PascalCase** para componentes
- Nombres que describan su propósito

**Ejemplo:**

```typescript
// ✅ Descriptivo
export function UserProfileCard() { }
export function DashboardStatsGrid() { }

// ❌ Genérico
export function Card() { }
export function Grid() { }
```

#### Constantes

- **UPPER_SNAKE_CASE** para constantes globales
- **camelCase** para constantes locales

**Ejemplo:**

```typescript
// Constante global
const MAX_RETRY_ATTEMPTS = 3;
const API_BASE_URL = 'https://api.example.com';

// Constante local
const defaultPageSize = 10;
```

### Organización de Imports

Ordenar imports de forma consistente:

1. Librerías externas (React, Mantine, etc.)
2. Imports internos absolutos (features, shared, layout)
3. Imports relativos
4. Tipos (pueden ir al final con `import type`)

**Ejemplo correcto:**

```typescript
import { useState, useEffect } from 'react';
import { Container, Card, Text } from '@mantine/core';
import { IconUsers } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';

import { useDashboardData } from '../hooks/useDashboardData';
import { dashboardService } from '../services/dashboardService';
import type { DashboardData } from '../services/dashboardService';
```

### Hooks Personalizados

#### Convenciones

- Prefijo `use` obligatorio
- Un hook = una responsabilidad
- Retornar objetos con propiedades nombradas

**Ejemplo correcto:**

```typescript
export function useDashboardData() {
  const [data, setData] = useState<DashboardData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Lógica del hook

  return { data, loading, error };
}
```

#### Hooks Compartidos

Colocar hooks reutilizables en `src/shared/hooks/`:

```typescript
// src/shared/hooks/useLocalStorage.ts
export function useLocalStorage<T>(key: string, initialValue: T) {
  // ...
}
```

### Manejo de Estado

#### Estado Local vs Global

- **Estado local**: `useState` para estado del componente
- **Estado compartido**: Context API o estado levantado
- **Estado del servidor**: Hooks personalizados con fetch

**Ejemplo de estado local:**

```typescript
function UserForm() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  // ...
}
```

**Ejemplo de estado compartido:**

```typescript
// Context para tema, autenticación, etc.
const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<'light' | 'dark'>('light');
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}
```

### Manejo de Efectos

#### useEffect

- Especificar dependencias correctamente
- Limpiar efectos cuando sea necesario
- Evitar efectos innecesarios

**Ejemplo correcto:**

```typescript
useEffect(() => {
  const controller = new AbortController();
  
  fetchData(controller.signal)
    .then(setData)
    .catch(setError);
  
  return () => {
    controller.abort(); // Limpiar al desmontar
  };
}, [/* dependencias */]);
```

### Servicios y APIs

#### Estructura de Servicios

Organizar servicios por dominio en `features/[domain]/services/`:

**Ejemplo:**

```typescript
// features/dashboard/services/dashboardService.ts
export interface DashboardData {
  stats: {
    totalUsers: number;
    totalRevenue: number;
    totalOrders: number;
    growthRate: number;
  };
  recentActivity: string[];
}

export const dashboardService = {
  async getDashboardData(): Promise<DashboardData> {
    const response = await fetch('/api/dashboard');
    if (!response.ok) {
      throw new Error('Failed to fetch dashboard data');
    }
    return response.json();
  },
};
```

#### Manejo de Errores en Servicios

Siempre manejar errores apropiadamente:

```typescript
export const userService = {
  async getUser(id: string): Promise<User> {
    try {
      const response = await fetch(`/api/users/${id}`);
      
      if (!response.ok) {
        if (response.status === 404) {
          throw new Error('User not found');
        }
        throw new Error(`Error ${response.status}: ${response.statusText}`);
      }
      
      return response.json();
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new Error('Unknown error while fetching user');
    }
  },
};
```

### Environment Configuration

#### Overview

The project uses environment-specific configuration files to manage different settings for development, staging, and production environments. All environment variables must be accessed through the centralized configuration module.

#### Environment Files

The project includes the following environment files:

- `.env.development` - Configuration for local development
- `.env.staging` - Configuration for staging environment
- `.env.production` - Configuration for production environment
- `.env.example` - Template file documenting all available variables

#### Using Environment Configuration

**Always use the centralized config module** instead of accessing `import.meta.env` directly:

**Example correct:**

```typescript
import { config, debugLog, isDevelopment } from '../../shared/config/env';

// Use config object
const apiUrl = config.apiUrl;
const appName = config.appName;

// Use helper functions
if (isDevelopment()) {
  debugLog('Debug information here');
}
```

**Example incorrect:**

```typescript
// ❌ Don't access import.meta.env directly
const apiUrl = import.meta.env.VITE_API_URL;
```

#### Available Configuration Properties

The `config` object provides type-safe access to:

- `config.apiUrl` - Base API URL
- `config.appName` - Application name
- `config.appVersion` - Application version
- `config.enableDebug` - Debug mode flag
- `config.apiTimeout` - API request timeout in milliseconds
- `config.environment` - Current environment ('development' | 'staging' | 'production')

#### Helper Functions

The config module provides utility functions:

```typescript
import { 
  isDevelopment, 
  isStaging, 
  isProduction, 
  debugLog 
} from '../../shared/config/env';

// Environment checks
if (isDevelopment()) {
  // Development-only code
}

// Debug logging (only logs when enableDebug is true)
debugLog('User data:', userData);
```

#### Using Config in Services

Always use the config module in service files:

**Example:**

```typescript
import { config } from '../../shared/config/env';

export const dashboardService = {
  async getDashboardData(): Promise<DashboardData> {
    const response = await fetch(`${config.apiUrl}/dashboard`, {
      signal: AbortSignal.timeout(config.apiTimeout),
    });
    
    if (!response.ok) {
      throw new Error('Failed to fetch dashboard data');
    }
    
    return response.json();
  },
};
```

#### Switching Between Environments

Use npm scripts to switch between environments:

```bash
# Development (uses .env.development)
npm run dev

# Development with staging config (uses .env.staging)
npm run dev:staging

# Development with production config (uses .env.production)
npm run dev:prod

# Build for staging
npm run build:staging

# Build for production
npm run build:prod
```

#### Adding New Environment Variables

When adding new environment variables:

1. Add the variable to `.env.example` with documentation
2. Add the variable to all environment files (`.env.development`, `.env.staging`, `.env.production`)
3. Update `src/shared/config/env.ts` to include the new variable in the `AppConfig` interface
4. Add validation or default value handling in the config module

**Example:**

```typescript
// In .env.example
# New Feature Flag
VITE_ENABLE_NEW_FEATURE=false

// In src/shared/config/env.ts
interface AppConfig {
  // ... existing properties
  enableNewFeature: boolean;
}

export const config: AppConfig = {
  // ... existing properties
  enableNewFeature: getBooleanEnv('VITE_ENABLE_NEW_FEATURE', false),
};
```

#### Best Practices

1. **Never commit sensitive data** - Only commit `.env.example`, never actual `.env` files
2. **Use type-safe access** - Always use the `config` module, never `import.meta.env` directly
3. **Validate required variables** - The config module validates required variables and throws errors if missing
4. **Use helper functions** - Prefer `isDevelopment()`, `isStaging()`, etc. over checking `config.environment` directly
5. **Use debugLog** - Use `debugLog()` instead of `console.log()` for debug messages
6. **Document variables** - Always document new variables in `.env.example`

### ESLint y Code Quality

#### Seguir Reglas de ESLint

El proyecto tiene ESLint configurado. Respetar las reglas:

```bash
# Check code
npm run lint

# Auto-fix when possible
npm run lint -- --fix
```

#### Reglas Importantes

- Usar `const` en lugar de `let` cuando sea posible
- Preferir arrow functions para callbacks
- No usar `var`
- Preferir template literals sobre concatenación

**Ejemplo correcto:**

```typescript
const items = data.map((item) => (
  <Card key={item.id}>
    {item.name}
  </Card>
));

const message = `User ${user.name} has been created`;
```

### Git y Commits

#### Mensajes de Commit

Seguir Conventional Commits (el proyecto tiene commitlint):

```
feat: add UserProfile component
fix: fix error in totals calculation
docs: update README with installation instructions
refactor: reorganize services structure
test: add tests for useDashboardData
chore: update dependencies
```

#### Branching

- `main`: Production code
- `develop`: Development code
- `feature/feature-name`: New features
- `fix/fix-name`: Bug fixes

### Performance

#### Optimizaciones Comunes

- Usar `React.memo` para componentes que se re-renderizan frecuentemente
- Usar `useMemo` para cálculos costosos
- Usar `useCallback` para funciones pasadas como props

**Ejemplo:**

```typescript
const expensiveValue = useMemo(() => {
  return heavyCalculation(data);
}, [data]);

const handleClick = useCallback(() => {
  doSomething(id);
}, [id]);

const MemoizedComponent = React.memo(function Component({ data }) {
  return <ComplexVisualization data={data} />;
});
```

#### Code Splitting

Usar lazy loading para rutas:

```typescript
import { lazy, Suspense } from 'react';

const Dashboard = lazy(() => import('./features/dashboard'));

function App() {
  return (
    <Suspense fallback={<Loader />}>
      <Routes>
        <Route path="/dashboard" element={<Dashboard />} />
      </Routes>
    </Suspense>
  );
}
```

### Testing

**IMPORTANT**: See `.cursor/rules/testing.mdc` for comprehensive testing rules and requirements.

Key requirements:
- **90% minimum code coverage** required before committing
- All new code must have corresponding tests
- Tests are enforced via pre-commit hooks
- Use Vitest + React Testing Library for testing

**Write testable code:**

- Separate logic from presentation
- Use pure functions when possible
- Make hooks and services easy to mock

**Example of testable code:**

```typescript
// Separated logic - easy to test
export function calculateTotal(items: CartItem[]): number {
  return items.reduce((sum, item) => sum + item.price * item.quantity, 0);
}

// Component uses the logic
function CartSummary({ items }: { items: CartItem[] }) {
  const total = calculateTotal(items);
  return <Text>Total: ${total}</Text>;
}
```

**Run tests before committing:**

```bash
npm run test:coverage:check
```

## Herramientas de Desarrollo

### Vite

- Hot Module Replacement (HMR) automático
- Fast refresh para React
- Build optimizado para producción

### TypeScript

- Type checking estricto
- Autocompletado mejorado
- Refactoring seguro

### ESLint

- Linting automático
- Reglas de React y TypeScript
- Integración con editor

## Development Checklist

Before considering code complete, verify:

- [ ] Correct TypeScript types (no `any`)
- [ ] Imports organized correctly
- [ ] Consistent naming
- [ ] Folder structure respected
- [ ] ESLint without errors
- [ ] Readable and well-organized code
- [ ] Error handling implemented
- [ ] Performance considered (memo, useMemo, useCallback when necessary)
- [ ] Code, comments, and variable names in English
- [ ] Environment variables accessed through config module (not import.meta.env directly)
- [ ] Appropriate environment used for development/testing (dev, dev:staging, dev:prod)
- [ ] All new code has corresponding tests (see `.cursor/rules/testing.mdc`)
- [ ] Test coverage is at least 90% for new code
- [ ] All tests pass before committing
